name: Build and Release from Source

on:
  # Monitor upstream OptiScaler repository for pushes to master
  repository_dispatch:
    types: [upstream-push]
  workflow_dispatch:
  push:
    branches:
        - main

permissions:
  contents: write
  actions: read

jobs:
  build-and-release:
    runs-on: windows-latest
    
    steps:
    - name: Checkout this repository
      uses: actions/checkout@v4

    - name: Checkout OptiScaler upstream repository
      uses: actions/checkout@v4
      with:
        repository: optiscaler/OptiScaler
        ref: master
        path: optiscaler-source
        submodules: 'true'  # Important: check out submodules like upstream
        
    - name: Extract version from resource.h
      id: extract_version
      shell: powershell
      run: |
        cd optiscaler-source
        
        # Read resource.h to extract version information
        $resourceFile = "OptiScaler\resource.h"
        if (-not (Test-Path $resourceFile)) {
            Write-Error "resource.h not found at $resourceFile"
            exit 1
        }
        
        $content = Get-Content $resourceFile
        
        # Extract version components (following upstream pattern)
        $majorMatch = $content | Select-String '#define\s+VER_FILE_VERSION_MAJOR\s+(\d+)'
        $minorMatch = $content | Select-String '#define\s+VER_FILE_VERSION_MINOR\s+(\d+)'
        $patchMatch = $content | Select-String '#define\s+VER_FILE_VERSION_PATCH\s+(\d+)'
        $buildMatch = $content | Select-String '#define\s+VER_FILE_VERSION_BUILD\s+(\d+)'
        
        if (-not $majorMatch -or -not $minorMatch -or -not $patchMatch -or -not $buildMatch) {
            Write-Error "Could not extract all version components from resource.h"
            exit 1
        }
        
        $major = $majorMatch.Matches[0].Groups[1].Value
        $minor = $minorMatch.Matches[0].Groups[1].Value
        $patch = $patchMatch.Matches[0].Groups[1].Value
        $build = $buildMatch.Matches[0].Groups[1].Value
        
        $version = "$major.$minor.$patch.$build"
        
        # Get commit info
        $commitSha = git rev-parse HEAD
        $shortSha = git rev-parse --short HEAD
        $commitDate = Get-Date -Format "yyyyMMdd-HHmm"
        
        Write-Output "Extracted version: $version"
        Write-Output "OptiScaler HEAD SHA: $commitSha"
        Write-Output "Short SHA: $shortSha"
        Write-Output "Commit Date: $commitDate"
        
        # Create version-based release name (following upstream pattern)
        $releaseName = "source-v$version-$commitDate-$shortSha"
        
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "commit_sha=$commitSha" >> $env:GITHUB_OUTPUT
        echo "short_sha=$shortSha" >> $env:GITHUB_OUTPUT
        echo "commit_date=$commitDate" >> $env:GITHUB_OUTPUT
        echo "release_name=$releaseName" >> $env:GITHUB_OUTPUT

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Build OptiScaler (following upstream approach)
      shell: powershell
      run: |
        cd optiscaler-source
        Write-Output "Building OptiScaler following upstream approach..."
        
        # Use the same build approach as upstream just_build.yml
        # Build Release x64 configuration
        msbuild OptiScaler.sln /p:Configuration=Release /p:Platform=x64 /m
        
        if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed with exit code $LASTEXITCODE"
            exit 1
        }
        
        Write-Output "Build completed successfully!"
        
        # Verify the main output exists
        $mainDll = "x64\Release\OptiScaler.dll"
        if (-not (Test-Path $mainDll)) {
            Write-Error "Main output OptiScaler.dll not found at $mainDll"
            exit 1
        }
        
    - name: Verify build outputs and organize artifacts
      shell: powershell
      run: |
        cd optiscaler-source
        $version = "${{ steps.extract_version.outputs.version }}"
        
        Write-Output "=== Build Output Verification ==="
        
        # Check for expected outputs
        $expectedFiles = @(
            "x64\Release\OptiScaler.dll"
        )
        
        $missingFiles = @()
        foreach ($file in $expectedFiles) {
            if (Test-Path $file) {
                $fileInfo = Get-Item $file
                Write-Output "‚úÖ Found: $file ($($fileInfo.Length) bytes)"
            } else {
                $missingFiles += $file
                Write-Output "‚ùå Missing: $file"
            }
        }
        
        if ($missingFiles.Count -gt 0) {
            Write-Error "Missing required build outputs: $($missingFiles -join ', ')"
            exit 1
        }
        
        # List all files in the release directory for transparency
        Write-Output "=== All files in Release directory ==="
        Get-ChildItem -Path "x64\Release" -Recurse | ForEach-Object {
            if ($_.PSIsContainer) {
                Write-Output "üìÅ $($_.FullName.Replace($PWD, '.'))"
            } else {
                Write-Output "üìÑ $($_.FullName.Replace($PWD, '.')) ($($_.Length) bytes)"
            }
        }
        
        Write-Output "=== Build verification completed successfully ==="

    - name: Package OptiScaler build artifacts
      shell: powershell
      run: |
        $commitDate = "${{ steps.extract_version.outputs.commit_date }}"
        $shortSha = "${{ steps.extract_version.outputs.short_sha }}"
        $version = "${{ steps.extract_version.outputs.version }}"
        
        # Create artifact directory
        $artifactDir = "${{ github.workspace }}\x64\Release\a"
        New-Item -ItemType Directory -Force -Path $artifactDir
        
        # Copy built files from OptiScaler output
        $sourceDir = "${{ github.workspace }}\optiscaler-source\x64\Release"
        
        if (Test-Path "$sourceDir\OptiScaler.dll") {
            Copy-Item -Path "$sourceDir\OptiScaler.dll" -Destination $artifactDir
            Write-Output "Copied OptiScaler.dll"
        } else {
            Write-Error "OptiScaler.dll not found in build output"
            exit 1
        }
        
        # Look for other build outputs and copy them
        $otherFiles = Get-ChildItem -Path $sourceDir -File | Where-Object { $_.Name -ne "OptiScaler.dll" }
        foreach ($file in $otherFiles) {
            Copy-Item -Path $file.FullName -Destination $artifactDir
            Write-Output "Copied $($file.Name)"
        }
        
        # Create a comprehensive 7z archive following upstream pattern
        $archiveName = "OptiScaler-v$version-source-$commitDate-$shortSha.7z"
        $archivePath = "$artifactDir\$archiveName"
        
        # Install 7-Zip first (following upstream approach)
        Write-Output "Installing 7-Zip..."
        Invoke-WebRequest -Uri "https://www.7-zip.org/a/7z2301-x64.exe" -OutFile "7z-installer.exe"
        Start-Process -FilePath "7z-installer.exe" -ArgumentList "/S" -Wait
        
        # Add 7-Zip to PATH
        $env:PATH += ";C:\Program Files\7-Zip"
        
        # Create 7z archive
        & "C:\Program Files\7-Zip\7z.exe" a -t7z "$archivePath" "$sourceDir\*"
        
        if ($LASTEXITCODE -eq 0) {
            Write-Output "Created 7z archive: $archiveName"
        } else {
            Write-Error "Failed to create 7z archive"
            exit 1
        }

    - name: Download latest dlssg-to-fsr3 release
      id: dlssg_download
      shell: powershell
      run: |
        # Get the latest release info from the API
        $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/xXJSONDeruloXx/dlssg-to-fsr3/releases/latest"
        
        # Find the standard ZIP asset (not Universal or DLSSTweaks.Edition)
        $asset = $releases.assets | Where-Object { 
          $_.name -like "dlssg-to-fsr3-*.zip" -and 
          $_.name -notlike "*Universal*" -and 
          $_.name -notlike "*DLSSTweaks.Edition*" 
        } | Select-Object -First 1
        
        if (-not $asset) {
            Write-Error "Could not find appropriate dlssg-to-fsr3 release asset"
            exit 1
        }
        
        Write-Output "Downloading $($asset.name)..."
        
        # Download the asset
        $downloadUrl = $asset.browser_download_url
        $zipPath = "${{ github.workspace }}\dlssg-to-fsr3.zip"
        Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath
        
        # Extract the ZIP file
        $extractPath = "${{ github.workspace }}\dlssg-temp"
        Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        
        # Find the DLL file in the extracted directory
        $dllPath = Get-ChildItem -Path $extractPath -Recurse -Filter "dlssg_to_fsr3_amd_is_better.dll" | Select-Object -First 1 -ExpandProperty FullName
        
        if (-not $dllPath) {
            Write-Error "Could not find dlssg_to_fsr3_amd_is_better.dll in the extracted files"
            exit 1
        }
        
        # Copy the DLL to the artifact directory
        Copy-Item -Path $dllPath -Destination "${{ github.workspace }}\x64\Release\a\"
        
        Write-Output "Successfully copied dlssg_to_fsr3_amd_is_better.dll to artifact directory"
      continue-on-error: false
    
    - name: Download latest fakenvapi release
      id: fakenvapi_download
      shell: powershell
      run: |
        # Get the latest release info from the API
        $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/FakeMichau/fakenvapi/releases/latest"
        
        # Find the fakenvapi.zip asset
        $asset = $releases.assets | Where-Object { 
          $_.name -eq "fakenvapi.zip"
        } | Select-Object -First 1
        
        if (-not $asset) {
            Write-Error "Could not find fakenvapi.zip in the latest release"
            exit 1
        }
        
        Write-Output "Downloading $($asset.name)..."
        
        # Download the asset
        $downloadUrl = $asset.browser_download_url
        $zipPath = "${{ github.workspace }}\fakenvapi.zip"
        Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath
        
        # Extract the ZIP file
        $extractPath = "${{ github.workspace }}\fakenvapi-temp"
        Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        
        # Find the required files in the extracted directory
        $nvapi64Path = Get-ChildItem -Path $extractPath -Recurse -Filter "nvapi64.dll" | Select-Object -First 1 -ExpandProperty FullName
        $fakenvApiIniPath = Get-ChildItem -Path $extractPath -Recurse -Filter "fakenvapi.ini" | Select-Object -First 1 -ExpandProperty FullName
        
        if (-not $nvapi64Path) {
            Write-Error "Could not find nvapi64.dll in the extracted files"
            exit 1
        }
        
        if (-not $fakenvApiIniPath) {
            Write-Error "Could not find fakenvapi.ini in the extracted files"
            exit 1
        }
        
        # Copy the files to the artifact directory
        Copy-Item -Path $nvapi64Path -Destination "${{ github.workspace }}\x64\Release\a\"
        Copy-Item -Path $fakenvApiIniPath -Destination "${{ github.workspace }}\x64\Release\a\"
        
        Write-Output "Successfully copied nvapi64.dll and fakenvapi.ini to artifact directory"
      continue-on-error: false

    - name: List consolidated artifacts
      shell: powershell
      run: |
        Write-Output "Contents of consolidated artifact directory:"
        Get-ChildItem -Path "${{ github.workspace }}\x64\Release\a" -Recurse | ForEach-Object {
            Write-Output "  $($_.Name) ($($_.Length) bytes)"
        }

    - name: Prepare release assets and create archive
      shell: powershell
      run: |
        $version = "${{ steps.extract_version.outputs.version }}"
        $commitDate = "${{ steps.extract_version.outputs.commit_date }}"
        $shortSha = "${{ steps.extract_version.outputs.short_sha }}"
        
        # Get list of all files in the artifact directory for individual upload
        $artifactDir = "${{ github.workspace }}\x64\Release\a"
        $files = Get-ChildItem -Path $artifactDir -File
        
        $fileList = @()
        foreach ($file in $files) {
            $fileList += @{
                "path" = $file.FullName
                "name" = $file.Name
            }
            Write-Output "Will upload: $($file.Name) ($($file.Length) bytes)"
        }
        
        # Convert to JSON for passing to upload steps
        $filesJson = $fileList | ConvertTo-Json -Compress
        echo "files_to_upload=$filesJson" >> $env:GITHUB_OUTPUT
        echo "files_count=$($fileList.Count)" >> $env:GITHUB_OUTPUT
        
        # Create a comprehensive archive name following upstream pattern
        $archiveName = "OptiScaler-v$version-source-complete-$commitDate-$shortSha.7z"
        Write-Output "Archive name: $archiveName"
        echo "archive_name=$archiveName" >> $env:GITHUB_OUTPUT
      id: prepare_assets

    - name: Get component versions
      shell: powershell
      run: |
        # Get dlssg-to-fsr3 version
        $dlssgRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/xXJSONDeruloXx/dlssg-to-fsr3/releases/latest"
        $dlssgVersion = $dlssgRelease.tag_name
        
        # Get fakenvapi version
        $fakenvApiRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/FakeMichau/fakenvapi/releases/latest"
        $fakenvApiVersion = $fakenvApiRelease.tag_name
        
        echo "dlssg_version=$dlssgVersion" >> $env:GITHUB_OUTPUT
        echo "fakenvapi_version=$fakenvApiVersion" >> $env:GITHUB_OUTPUT
        
        Write-Output "Component versions:"
        Write-Output "  dlssg-to-fsr3: $dlssgVersion"
        Write-Output "  fakenvapi: $fakenvApiVersion"
      id: get_versions

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.extract_version.outputs.release_name }}
        release_name: ${{ steps.extract_version.outputs.release_name }} - Source Build
        body: |
          üî® **Source Build Release**
          
          This release contains OptiScaler built from the latest source code, combined with the latest versions of complementary tools.
          
          ## üì¶ Components Included
          
          - **OptiScaler**: v${{ steps.extract_version.outputs.version }} built from source at commit [`${{ steps.extract_version.outputs.commit_sha }}`](https://github.com/optiscaler/OptiScaler/commit/${{ steps.extract_version.outputs.commit_sha }})
          - **dlssg-to-fsr3**: ${{ steps.get_versions.outputs.dlssg_version }} - `dlssg_to_fsr3_amd_is_better.dll`
          - **fakenvapi**: ${{ steps.get_versions.outputs.fakenvapi_version }} - `nvapi64.dll` and `fakenvapi.ini`
          
          ## üîß Build Information
          
          - **Source Repository**: [OptiScaler](https://github.com/optiscaler/OptiScaler)
          - **Branch**: master
          - **Version**: ${{ steps.extract_version.outputs.version }}
          - **Commit SHA**: `${{ steps.extract_version.outputs.commit_sha }}`
          - **Build Date**: ${{ steps.extract_version.outputs.commit_date }}
          - **Trigger**: `${{ github.event_name }}`
          
          ## ‚ö†Ô∏è Important Notes
          
          - This is a **pre-release** built from the latest source code
          - May contain experimental features, bugs, or unstable code
          - Use at your own risk in production environments
          - For stable releases, use the main bleeding-edge releases or official [OptiScaler releases](https://github.com/optiscaler/OptiScaler/releases)
          
          ## üîß Installation
          
          1. Download the individual files below
          2. Extract any archives if needed
          3. Copy files to your game directory
          4. Follow the OptiScaler documentation for configuration
          
          ---
          
          **Workflow Information:**
          - Build Workflow: [View Details](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - Built with: MSBuild on Windows following upstream approach
        draft: false
        prerelease: true
      id: create_release

    - name: Upload Release Assets
      shell: powershell
      run: |
        # Parse the files list and upload each one individually
        $files = '${{ steps.prepare_assets.outputs.files_to_upload }}' | ConvertFrom-Json
        $uploadUrl = "${{ steps.create_release.outputs.upload_url }}"
        
        $headers = @{
          'Authorization' = 'Bearer ${{ secrets.GITHUB_TOKEN }}'
          'Accept' = 'application/vnd.github.v3+json'
        }
        
        foreach ($file in $files) {
            $filePath = $file.path
            $fileName = $file.name
            
            Write-Output "Uploading: $fileName"
            
            # Determine content type based on file extension
            $contentType = switch -Regex ($fileName) {
                '\.dll$' { 'application/octet-stream' }
                '\.7z$' { 'application/x-7z-compressed' }
                '\.zip$' { 'application/zip' }
                '\.ini$' { 'text/plain' }
                default { 'application/octet-stream' }
            }
            
            # Upload URL format: {upload_url}?name={name}&label={label}
            $cleanUploadUrl = $uploadUrl -replace '\{.*\}', ''
            $fullUploadUrl = "${cleanUploadUrl}?name=${fileName}"
            
            try {
                # Read file content
                $fileBytes = [System.IO.File]::ReadAllBytes($filePath)
                
                # Upload the file
                $response = Invoke-RestMethod -Uri $fullUploadUrl -Method POST -Headers $headers -Body $fileBytes -ContentType $contentType
                Write-Output "‚úÖ Successfully uploaded: $fileName"
            } catch {
                Write-Error "‚ùå Failed to upload $fileName : $($_.Exception.Message)"
                exit 1
            }
        }
        
        Write-Output "üéâ All source build files uploaded successfully!"

    - name: Build Summary
      shell: powershell
      run: |
        Write-Output "=== üöÄ BUILD SUMMARY ==="
        Write-Output ""
        Write-Output "‚úÖ Source Build Completed Successfully"
        Write-Output ""
        Write-Output "üì¶ Release Information:"
        Write-Output "  ‚Ä¢ Tag: ${{ steps.extract_version.outputs.release_name }}"
        Write-Output "  ‚Ä¢ Version: ${{ steps.extract_version.outputs.version }}"
        Write-Output "  ‚Ä¢ Commit: ${{ steps.extract_version.outputs.commit_sha }}"
        Write-Output "  ‚Ä¢ Build Date: ${{ steps.extract_version.outputs.commit_date }}"
        Write-Output ""
        Write-Output "üîß Components Included:"
        Write-Output "  ‚Ä¢ OptiScaler v${{ steps.extract_version.outputs.version }} (built from source)"
        Write-Output "  ‚Ä¢ dlssg-to-fsr3 ${{ steps.get_versions.outputs.dlssg_version }}"
        Write-Output "  ‚Ä¢ fakenvapi ${{ steps.get_versions.outputs.fakenvapi_version }}"
        Write-Output ""
        Write-Output "üìÑ Files Uploaded: ${{ steps.prepare_assets.outputs.files_count }}"
        Write-Output ""
        Write-Output "üéØ Release URL: ${{ steps.create_release.outputs.html_url }}"
        Write-Output ""
        Write-Output "=== ‚ú® Ready for Testing! ==="

    - name: Update repository description
      shell: powershell
      run: |
        $headers = @{
          'Authorization' = 'Bearer ${{ secrets.GITHUB_TOKEN }}'
          'Accept' = 'application/vnd.github.v3+json'
          'Content-Type' = 'application/json'
        }
        
        $body = @{
          description = "üöÄ Automated releases for OptiScaler | Latest Source: ${{ steps.extract_version.outputs.release_name }}"
        } | ConvertTo-Json
        
        try {
          Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}" -Method PATCH -Headers $headers -Body $body
          Write-Output "Updated repository description"
        } catch {
          Write-Output "Failed to update repository description: $($_.Exception.Message)"
        }

    - name: Cleanup temporary files
      if: always()
      shell: powershell
      run: |
        # Clean up temporary directories and files
        $tempPaths = @(
          "${{ github.workspace }}\dlssg-temp",
          "${{ github.workspace }}\fakenvapi-temp",
          "${{ github.workspace }}\optiscaler-source",
          "${{ github.workspace }}\*.zip"
        )
        
        foreach ($path in $tempPaths) {
          if (Test-Path $path) {
            Remove-Item -Path $path -Recurse -Force -ErrorAction SilentlyContinue
            Write-Output "Cleaned up: $path"
          }
        }
